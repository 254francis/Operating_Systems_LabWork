#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>
#include <string.h>
#include <ctype.h>

// ------------------ Global Constants ------------------
#define NUM_PHILOSOPHERS    5
#define MAX_EATING_CYCLES   3
#define THINKING_TIME_MAX   3
#define EATING_TIME_MAX     2

// ------------------ Philosopher States ----------------
typedef enum {
    THINKING,
    HUNGRY,
    EATING
} philosopher_state_t;

// ------------------ Globals ---------------------------
sem_t chopsticks[NUM_PHILOSOPHERS];          // Binary semaphores for chopsticks
sem_t waiter;                                 // Limits concurrent diners to N-1 (used in waiter solution)
pthread_mutex_t state_mutex;                  // Protects state[] and counters
pthread_mutex_t output_mutex;                 // Serializes printing
philosopher_state_t state[NUM_PHILOSOPHERS];  // Per-philosopher state
int eating_count[NUM_PHILOSOPHERS];           // Meals per philosopher
int total_meals = 0;                          // Total meals across all philosophers

typedef enum {
    SOL_ASYM = 1,
    SOL_HIER = 2,
    SOL_WAITER = 3
} solution_t;

solution_t solution_type = SOL_ASYM;          // Default unless overridden by argv

// ------------------ Prototypes -
void* philosopher_asymmetric(void* arg);
void* philosopher_hierarchy(void* arg);
void* philosopher_waiter_fn(void* arg);

void initialize_sync_primitives(void);
void cleanup_sync_primitives(void);
void print_status(int philosopher_id, const char* action);
void print_table_state(void);
int  get_left_chopstick(int philosopher_id);
int  get_right_chopstick(int philosopher_id);
void simulate_thinking(int philosopher_id);
void simulate_eating(int philosopher_id);

// ------------------ Helpers ---------------------------
int get_left_chopstick(int philosopher_id) { return philosopher_id; }
int get_right_chopstick(int philosopher_id){ return (philosopher_id + 1) % NUM_PHILOSOPHERS; }

void safe_sem_getvalue(sem_t* s, int* out) {

    if (sem_getvalue(s, out) != 0) *out = 0;
}

void print_table_state(void) {
    // visualization of philosopher states and meal count
    printf("   Table State: ");
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        char c = '?';
        switch (state[i]) {
            case THINKING: c = 'T'; break;
            case HUNGRY:   c = 'H'; break;
            case EATING:   c = 'E'; break;
        }
        printf("P%d(%c)%s", i, c, (i < NUM_PHILOSOPHERS - 1) ? " " : "");
    }
    printf(" | Meals: %d", total_meals);
}

void print_status(int philosopher_id, const char* action) {
    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d: %s\n", philosopher_id, action);
    print_table_state();
    printf("\n");
    pthread_mutex_unlock(&output_mutex);
}

void simulate_thinking(int philosopher_id) {
    pthread_mutex_lock(&state_mutex);
    state[philosopher_id] = THINKING;
    pthread_mutex_unlock(&state_mutex);

    int think_time = (rand() % THINKING_TIME_MAX) + 1;
    print_status(philosopher_id, "Started thinking");
    sleep(think_time);
}

void simulate_eating(int philosopher_id) {
    pthread_mutex_lock(&state_mutex);
    state[philosopher_id] = EATING;
    eating_count[philosopher_id]++;
    total_meals++;
    pthread_mutex_unlock(&state_mutex);

    int eat_time = (rand() % EATING_TIME_MAX) + 1;
    print_status(philosopher_id, "Started eating");
    sleep(eat_time);
    print_status(philosopher_id, "Finished eating");
}

void initialize_sync_primitives(void) {
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        if (sem_init(&chopsticks[i], 0, 1) != 0) {
            perror("sem_init(chopstick) failed");
            exit(EXIT_FAILURE);
        }
        state[i] = THINKING;
        eating_count[i] = 0;
    }
    // Waiter allows at most N-1 philosophers to try to dine simultaneously
    if (sem_init(&waiter, 0, NUM_PHILOSOPHERS - 1) != 0) {
        perror("sem_init(waiter) failed");
        exit(EXIT_FAILURE);
    }
    if (pthread_mutex_init(&state_mutex, NULL) != 0 ||
        pthread_mutex_init(&output_mutex, NULL) != 0) {
        perror("pthread_mutex_init failed");
        exit(EXIT_FAILURE);
    }
    printf("All synchronization primitives initialized successfully\n\n");
}

void cleanup_sync_primitives(void) {
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) sem_destroy(&chopsticks[i]);
    sem_destroy(&waiter);
    pthread_mutex_destroy(&state_mutex);
    pthread_mutex_destroy(&output_mutex);
}



/*
 * SOLUTION 1: Asymmetric (odd picks right first, even picks left first)
 * Breaks circular wait by asymmetric acquisition order.
 */
void* philosopher_asymmetric(void* arg) {
    int id = *(int*)arg;
    int L = get_left_chopstick(id);
    int R = get_right_chopstick(id);

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d started (Asymmetric Solution)\n", id);
    pthread_mutex_unlock(&output_mutex);

    for (int cycle = 0; cycle < MAX_EATING_CYCLES; cycle++) {
        simulate_thinking(id);

        pthread_mutex_lock(&state_mutex);
        state[id] = HUNGRY;
        pthread_mutex_unlock(&state_mutex);
        print_status(id, "Became hungry");

        if (id % 2 == 0) {
            print_status(id, "Trying to pick up LEFT chopstick");
            sem_wait(&chopsticks[L]);
            print_status(id, "Picked up LEFT chopstick");

            print_status(id, "Trying to pick up RIGHT chopstick");
            sem_wait(&chopsticks[R]);
            print_status(id, "Picked up RIGHT chopstick");
        } else {
            print_status(id, "Trying to pick up RIGHT chopstick");
            sem_wait(&chopsticks[R]);
            print_status(id, "Picked up RIGHT chopstick");

            print_status(id, "Trying to pick up LEFT chopstick");
            sem_wait(&chopsticks[L]);
            print_status(id, "Picked up LEFT chopstick");
        }

        simulate_eating(id);

        sem_post(&chopsticks[L]);
        sem_post(&chopsticks[R]);
        print_status(id, "Put down both chopsticks");
    }

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d finished all meals (Total: %d)\n", id, eating_count[id]);
    pthread_mutex_unlock(&output_mutex);
    return NULL;
}

/*
 * SOLUTION 2: Resource Hierarchy (global ordering)
 * Always pick lower-indexed chopstick first, then higher. No cycles possible.
 */
void* philosopher_hierarchy(void* arg) {
    int id = *(int*)arg;
    int L = get_left_chopstick(id);
    int R = get_right_chopstick(id);
    int first = (L < R) ? L : R;
    int second = (L < R) ? R : L;

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d started (Hierarchy Solution)\n", id);
    pthread_mutex_unlock(&output_mutex);

    for (int cycle = 0; cycle < MAX_EATING_CYCLES; cycle++) {
        simulate_thinking(id);

        pthread_mutex_lock(&state_mutex);
        state[id] = HUNGRY;
        pthread_mutex_unlock(&state_mutex);
        print_status(id, "Became hungry");

        // Acquire in global order
        print_status(id, "Trying to pick up lower-index chopstick");
        sem_wait(&chopsticks[first]);
        print_status(id, "Picked up lower-index chopstick");

        print_status(id, "Trying to pick up higher-index chopstick");
        sem_wait(&chopsticks[second]);
        print_status(id, "Picked up higher-index chopstick");

        simulate_eating(id);

        sem_post(&chopsticks[second]);
        sem_post(&chopsticks[first]);
        print_status(id, "Put down both chopsticks");
    }

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d finished all meals (Total: %d)\n", id, eating_count[id]);
    pthread_mutex_unlock(&output_mutex);
    return NULL;
}

/*
 * SOLUTION 3: Waiter (at most N-1 seated)
 * A semaphore (N-1) prevents all N from competing simultaneously => no deadlock.
 */
void* philosopher_waiter_fn(void* arg) {
    int id = *(int*)arg;
    int L = get_left_chopstick(id);
    int R = get_right_chopstick(id);

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d started (Waiter Solution)\n", id);
    pthread_mutex_unlock(&output_mutex);

    for (int cycle = 0; cycle < MAX_EATING_CYCLES; cycle++) {
        simulate_thinking(id);

        pthread_mutex_lock(&state_mutex);
        state[id] = HUNGRY;
        pthread_mutex_unlock(&state_mutex);
        print_status(id, "Became hungry");

        // Ask waiter permission to sit (limits concurrency to N-1)
        print_status(id, "Requesting permission from waiter");
        sem_wait(&waiter);
        print_status(id, "Waiter granted permission");

        // Now safely pick both chopsticks
        print_status(id, "Trying to pick up LEFT chopstick");
        sem_wait(&chopsticks[L]);
        print_status(id, "Picked up LEFT chopstick");

        print_status(id, "Trying to pick up RIGHT chopstick");
        sem_wait(&chopsticks[R]);
        print_status(id, "Picked up RIGHT chopstick");

        simulate_eating(id);

        sem_post(&chopsticks[R]);
        sem_post(&chopsticks[L]);
        print_status(id, "Put down both chopsticks");

        // Leave table, allowing another philosopher to try
        sem_post(&waiter);
        print_status(id, "Informed waiter and left table");
    }

    pthread_mutex_lock(&output_mutex);
    printf("Philosopher %d finished all meals (Total: %d)\n", id, eating_count[id]);
    pthread_mutex_unlock(&output_mutex);
    return NULL;
}

// ------------------ Main ------------------------------
static solution_t parse_solution(const char* s) {
    if (!s) return SOL_ASYM;
    char tmp[16]; size_t n = strlen(s);
    n = (n < sizeof(tmp)-1) ? n : sizeof(tmp)-1;
    for (size_t i = 0; i < n; i++) tmp[i] = (char)tolower((unsigned char)s[i]);
    tmp[n] = '\0';
    if (strcmp(tmp, "asym") == 0 || strcmp(tmp, "asymmetric") == 0) return SOL_ASYM;
    if (strcmp(tmp, "hier") == 0 || strcmp(tmp, "hierarchy") == 0)   return SOL_HIER;
    if (strcmp(tmp, "waiter") == 0)                                   return SOL_WAITER;
    return SOL_ASYM;
}

static void print_usage(const char* prog) {
    fprintf(stderr,
        "Usage: %s [asym|hier|waiter]\n"
        "  asym   : Asymmetric (odd picks right first, even picks left first)\n"
        "  hier   : Resource hierarchy (always pick lower-index chopstick first)\n"
        "  waiter : Waiter limits concurrency to N-1\n", prog);
}

int main(int argc, char** argv) {
    if (argc >= 2) {
        solution_type = parse_solution(argv[1]);
        if (solution_type == SOL_ASYM && strcmp(argv[1], "asym") != 0 &&
            strcmp(argv[1], "asymmetric") != 0) {
            print_usage(argv[0]);
        }
    } else {
        printf("No mode provided; defaulting to 'asym'.\n");
        print_usage(argv[0]);
    }

    srand((unsigned int)time(NULL));
    initialize_sync_primitives();

    pthread_t threads[NUM_PHILOSOPHERS];
    int ids[NUM_PHILOSOPHERS];
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) ids[i] = i;

    // Create threads according to chosen solution
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        if (solution_type == SOL_ASYM) {
            if (pthread_create(&threads[i], NULL, philosopher_asymmetric, &ids[i]) != 0) {
                perror("pthread_create (asym) failed");
                exit(EXIT_FAILURE);
            }
        } else if (solution_type == SOL_HIER) {
            if (pthread_create(&threads[i], NULL, philosopher_hierarchy, &ids[i]) != 0) {
                perror("pthread_create (hier) failed");
                exit(EXIT_FAILURE);
            }
        } else { // SOL_WAITER
            if (pthread_create(&threads[i], NULL, philosopher_waiter_fn, &ids[i]) != 0) {
                perror("pthread_create (waiter) failed");
                exit(EXIT_FAILURE);
            }
        }
    }

    // Join
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("\nAll philosophers have finished eating.\n");
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        printf("Philosopher %d meals: %d\n", i, eating_count[i]);
    }
    printf("Total meals eaten: %d\n", total_meals);

    cleanup_sync_primitives();
    return 0;
}
